{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2022/12/26/202212/hello-world/"},{"title":"포스트에 이미지와 유튜브영상 올려보기","text":"이미지 업로드하기 source폴더 안에 images 폴더를 하나 만들어두고, 해당 폴더 안에 이미지를 넣어서 사용해야한다.포스트 제목과 같은 폴더를 하나 만든 후, 해당 폴더 안에 이미지를 넣어두고, 아래 코드처럼 작성하면 이미지를 불러올 수 있다. &lt;img src=&quot;/images/파일명.확장자?style=centerme&quot; alt=&quot;이미지설명&quot;/&gt; 조오금 불편하긴 하지만 익숙해져야 할듯..뒤에 style=centerme는 링크를 참고했다. style로 centerme를 주면 이미지가 자동으로 가운데정렬이 되는 방식. 유튜브 영상 올리기 {% youtube 영상링크 %}ex. {% youtube TdjbenWWSxc %} 그나마 유튜브는 Hexo에서 지원하는 양식을 사용하는게 제일 편하다.영상링크의 모든 주소는 아니고 id값만 가져오면 된다.","link":"/2022/12/27/202212/%ED%8F%AC%EC%8A%A4%ED%8A%B8%EC%97%90-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%99%80-%EC%9C%A0%ED%8A%9C%EB%B8%8C%EC%98%81%EC%83%81-%EC%98%AC%EB%A0%A4%EB%B3%B4%EA%B8%B0/"},{"title":"(2019카카오개발자겨울인턴십) 크레인 인형뽑기 게임","text":"문제설명게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.“죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음) 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요. 출처https://programmers.co.kr/learn/courses/30/lessons/64061 제한사항 board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다. 입출력문 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 문제해설moves 에 의해 특정원소를 스택구조에 담아서, 이전 스택값과 현재스택값이 같으면 result값을 1 더하는 식으로 해석할 수 있습니다. board의 1행인 [0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]값은 바구니에 담긴 인형들의 각 라인을 의미합니다. board[0]은 바구니의 최상단 라인인 셈이죠. def solution(board, moves): choose = [] # 뽑은 인형 리스트 front = -1 # Stack Answer = 0 # 정답 for m in moves: # 크레인 행동 for l in board: # 각 라인 검색 if l[m-1] == 0: continue # 해당 라인이 0이면 ( 인형이 없는 경우 ) choose.append(l[m-1]) # 인형을 적재리스트에 넣기 front += 1 # 스택에 2개이상 값이 있고, 두 인형이 같을 때 if front &gt; 0 and choose[front] == choose[front-1]: del choose[front] del choose[front-1] front -= 2 Answer += 2 l[m-1] = 0 # 인형을 뽑았으므로 해당 칸은 0으로 대입 break return Answer","link":"/2023/01/02/202301/(2019%EC%B9%B4%EC%B9%B4%EC%98%A4%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B2%A8%EC%9A%B8%EC%9D%B8%ED%84%B4%EC%8B%AD)-%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/"},{"title":"(2020카카오공채) 문자열 압축 문제","text":"문제설명데이터 처리 전문가가 되고 싶은 어피치는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 aabbaccc의 경우 2a2ba3c(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, abcabcdede와 같은 문자열은 전혀 압축되지 않습니다. 어피치는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, abcabcdede와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 abcabc2de가 되지만, 3개 단위로 자른다면 2abcdede가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력문 S Result “aabbaccc” 7 “ababcdcdababcdcd” 9 “abcabcdede” 8 “abcabcabcabcdededededede” 14 “xababcdcdababcdcd” 17 문제해설import mathdef solution(s): s_len = len(s) ans_list = [] for i in range(1,s_len+1): t = math.ceil(s_len/i) t1 = 0 index = 0 num = 1 answer = &quot;&quot; temp = &quot;&quot; temp2 = &quot;&quot; while (t1 &lt; t): temp = s[index:index+i] if (t1 != 0): temp2 = s[index-i:index] if (temp == temp2): num += 1 if (num == 1): answer = answer + temp2 if (num &gt;= 2 and t1 != 0 and temp2 != temp): answer = answer + str(num) + temp2 num = 1 index += i t1 += 1 if (t1==t): if (num&gt;=2): answer = answer + str(num) + temp2 num = 1 else: temp2 = s[index-i:index] answer = answer + temp2 ans_list.append(len(answer)) ans_list.sort() return ans_list[0] 무작정 코드를 써내려가서 많이 지져분합니다.. ㅎㅎ언어를 파이썬으로 작성했기 때문에 쉽게 해결할 수 있었던 것 같습니다.","link":"/2023/01/02/202301/(2020%EC%B9%B4%EC%B9%B4%EC%98%A4%EA%B3%B5%EC%B1%84)-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-%EB%AC%B8%EC%A0%9C/"},{"title":"Unpacking","text":"Unpacking이란?Unpacking은 여러개의 객체를 포함하고 있는 하나의 객체를 풀어줍니다.파이썬으로 코드를 짜다보면 다음과 같은 상황이 있습니다. 입력 받은 list에서 첫번째, 마지막 값만 가져오기혹은 반대로 입력 받은 list에서 첫번째, 마지막 값을 제외하기 파이썬은 해당 상황을 쉽게 해결 할 수 있습니다. lists = [1, 2, 3, 4, 5]first, *rest, last = listsprint(first, last)# 1 5print(rest)# [2, 3, 4] rest 앞에 *(asterisk)가 보이시나요?파이썬에서는 *(asterisk)를 다음과 같은 상황에 사용합니다. 곱셈, 거듭제곱 List형 컨테이너를 반복해서 확장 가변 인자 Unpacking 위의 코드에서 rest에 사용된 방법은 가변인자 입니다. 즉, 인자의 갯수가 몇개가 될지 확실하지 않을때 사용하는 거죠. 그런데 글제목은 Unpacking 이죠. Unpacking은 무엇일까요? lists = [1, 2, 3, 4, 5]for num in lists: print(num, end=' ')# 출력결과# 1 2 3 4 5 ​위의 코드는 lists 안의 내용물을 나열해서 출력하는 평범한 코드입니다.그리고 아래의 코드 방식으로도 같은 결과를 출력할 수 있습니다. lists = [1, 2, 3, 4, 5]print(*lists)# 출력결과# 1 2 3 4 5 같은 결과를 출력하죠? 이것을 List Unpacking 이라고 합니다.","link":"/2023/01/08/202301/Unpacking/"},{"title":"for-else문 활용하기","text":"for-else문?파이썬에는 특이하게 for-else문이 존재합니다.어떻게 생긴건가 궁금하시죠? for i in range(5): print(f'for문 i={i}')else: print(f'for문 종료') 이런 코드가 있을 때, 출력 결과는 이렇습니다. for문 i=0for문 i=1for문 i=2for문 i=3for문 i=4for문 종료 for-else문에서 else문이 작동하는 조건은 for문에 break가 걸리지 않았을 때에만 작동하게 됩니다. for i in range(5): print(f'for문 i={i}') if i == 4: breakelse: # i가 4일 때 break가 작동했기에, else문은 작동 안함 print(f'for문 종료') 이와 같은 특성때문에, for문 내부에 break가 작동했는지 안했는지 여부를 확인할 수 있고, 끝까지 for문을 돌게 되었을 때에만 특정 코드를 실행시킬 수도 있습니다. breakPoint = int(input()) # 입력값에 따라 break 위치 지정isLoop = Falsefor i in range(5): if i == breakPoint: breakelse: isLoop = Trueif isLoop is True: print('for문이 끝까지 동작함')else: print('for문이 도중에 정지됨') 입력에 따라 for문이 도중에 정지했는지 안했는지를 isLoop 변수로 확인할 수 있게 됩니다.","link":"/2023/01/03/202301/for-else%EB%AC%B8-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"yield와 제너레이터","text":"yield와 제너레이터함수 안에서 yield를 사용하면 함수는 제너레이터가 되며 yield에는 값(변수)을 지정합니다. def sample(): yield 'a' yield 1 yield 1.5for i in sample(): print(i)# 출력결과# a# 1# 1.5 for 반복문에 sample()를 지정해서 값을 출력해보면 yield에 지정했던 a, 1, 1.5가 나옵니다.제너레이터는 이터레이터를 생성해주는 함수로, 이터레이터와 사용법이 같습니다. def sample(): yield 'a' yield 1 yield 1.5s = sample() # yield를 사용하여 함수 바깥으로 전달한 값은 next의 반환값으로 나옴print(next(s))# aprint(next(s))# 1print(next(s))# 1.5 제너레이터는 함수 끝까지 도달하면 StopIteration 예외가 발생합니다. 마찬가지로 return도 함수를 끝내므로 return을 사용해서 함수 중간에 빠져나오면 StopIteration 예외가 발생합니다. def sample(): yield 'a' yield 1 yield 1.5 return 'return 값'try: s = sample() # yield를 사용하여 함수 바깥으로 전달한 값은 next의 반환값으로 나옴 next(s) # a next(s) # 1 next(s) # 1.5 next(s) # 예외발생!except StopIteration as e: print(e)# 출력결과# return 값","link":"/2023/01/08/202301/yield%EC%99%80-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"title":"Git rm에 대해서","text":"rm 명령어.gitignore에 등록한 파일이 이미 repo에 업로드된 경우 git rm --cached &lt;Filename&gt; 명령어를 통해, 파일을 제거하고 다시 push 하면 된다.–cached는 스테이징 영역에서만 파일이 삭제된다. 작업 디렉토리나 저장소에서는 삭제하지 않겠다는 의미이다. 참고로, rm &lt;Filename&gt; #앞에 git이 붙지 않은 rm은 작업 디렉토리에서 파일을 삭제하는 명령어git rm &lt;Filename&gt; #작업 디렉토리 및 스테이징 영역 모두 삭제 이렇게 git 여부에 따라, 원격저장소의 파일을 삭제할지 파일저장소의 파일을 삭제할지 정할 수 있다.","link":"/2023/01/02/202301/git-rm%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C/"},{"title":"딕셔너리의 type을 지정할 수 있는 defaultdict()","text":"딕셔너리?파이썬은 ‘딕셔너리’라는 연관 배열(Associative array) 자료형을 지원합니다.예시로, dict_a = {} #빈 딕셔너리dict_a['key'] = 'value'print(dict_a)# {'key': 'value'} 이렇게 { } 로 둘러쌓여있고, 각각의 요소는 Key : Value 형태로 이루어져 있습니다. defaultdict()는 작동하는 방식이 거의 비슷하지만, 주어진 객체의 기본값을 딕셔너리 값의 초기값으로 지정할 수 있습니다. int, list, set 등으로 초기화 할 수 있기 때문에 다양한 용도로 사용할 수 있습니다. 기본적인 사용법은 from collections import defaultdict #외부함수이기 때문에, 임포트해야 함.int_dict = defaultdict(int)print(int_dict)# defaultdict(&lt;class 'int'&gt;, {}) collections 안에서 defaultdict을 import 해서 쓰면 됩니다. ‘defaultdict’ 라는 말 그대로 처음 키를 지정할 때 값을 주지 않으면 해당 키에 대한 값(value)의 디폴트 값을 지정하겠다는 뜻입니다. 언제 필요할까?그렇다면, 이 defaultdict()는 어느 상황에서 사용되면 좋을까요?레퍼런스 문서에서 살펴보면, 다음과 같은 예제들이 등장합니다. ​https://docs.python.org/ko/3.8/library/collections.html?highlight=defaultdict#collections.defaultdict s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]d = defaultdict(list)for k, v in s: d[k].append(v)print(sorted(d.items()))# [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] 첫번째 예제를 살펴보면, defaultdict(list)과 같이 초기값을 리스트로 선언하여 리스트의 내용물을 매우 쉽게 분류합니다. 색상의 갯수를 셀 수 있는 것 뿐만 아니라, 각 색상별로 가지는 값을 리스트로 저장합니다. 단순히 예제만 보면, defaultdict을 사용해서 어떤 점에서 이득을 봤는지 알 수 없겠죠? s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]d = {} #defaultdict이 아닌 기본 딕셔너리for k, v in s: if not k in d: d[k] = [] #해당 키가 없으면, 리스트로 초기화 d[k].append(v)print(sorted(d.items()))# [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] 위와 같이 키가 존재하는지 검사하는 코드와 리스트로 초기화하는 코드가 추가로 필요합니다. 마지막으로 다른 예제 하나를 더 참고해보면, s = 'mississippi'd = defaultdict(int)for k in s: d[k] += 1print(sorted(d.items()))# [('i', 4), ('m', 1), ('p', 2), ('s', 4)] 이번 예제는 주어진 문자열을 알파벳으로 분류하여 갯수를 카운트합니다.이 역시 defaultdict()을 사용하지 않고, 만드려면 if를 통해 추가적인 검사코드와 초기화코드가 필요합니다.","link":"/2023/01/03/202301/%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-type%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-defaultdict()/"},{"title":"리눅스에 git 설치하기","text":"Git 설치하기sudo apt-get install git sudo apt install git Git 초기설정git --version # 버젼확인 git config --global user.name &quot;이름&quot;git config --global user.mail &quot;메일주소&quot; Git 프로젝트 복사하기git clone 프로젝트주소","link":"/2023/01/02/202301/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90-git-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"재귀(Recursion)와 분할정복(Divide and Conquer)","text":"재귀 (Recursion)재귀함수는 함수의 내부에서 자기 자신을 다시 호출하는 함수를 뜻한다.ex) 피보나치 수열, 팩토리얼 구현 등 일반적인 재귀 함수의 특징1. 함수의 호출이 트리 구조를 가진다.(트리란 사이클이 없는 연결 그래프를 의미) 2. 재귀적으로 함수를 호출하는 대신 바로 함수를 종료하는 기저 사례(base case)를 가진다.(기저 사례는 트리의 리프 노드(= 자식 노드가 없는 노드)에 해당) 분할 정복 (Divide and Conquer)큰 문제를 작은 문제로 분할(divide)하고 나눠진 작은 문제를 하나하나씩 정복(conquer)하여, 작은 문제의 답으로 큰 문제의 답을 구하는 것을 분할정복이라고 합니다. 이때 기저 사례(base case)를 둬서 더 이상 Divide하지 않고 바로 답을 구하는 기저 사례를 만들면 문제를 쪼갠 뒤 합치는 과정을 통해 원래 문제의 답을 구할 수 있다. 이러한 분할 정복의 구조 때문에 거의 대부분 분할 정복은 재귀로 구현된다. 중복 제거 (Memoization &amp; Tabulation)재귀함수는 알고리즘을 간단히 축약할 수 있다는 장점이 있지만, 스택 오버 플로어 문제와 런타임이 비교적 오래 걸린다는 단점이 있다. 단점을 극복하기 위해, Memoization과 Tabulation 이 두 개는 메모리를 더 사용하는 대신, 계산 시간을 줄인다. 예를 들어, 다음과 같은 피보나치 수열을 구하는 예제가 있다. def fibonacci(num): if num == 1 or num == 2: return 1 return fibonacci(num - 1) + fibonacci(num - 2) Memoization재귀함수에서 일어나는 중복 계산을 피하기 위한 방법이다. 피보나치를 계산해서 배열에 저장해놓고, 필요할 때 이용한다. 오버헤드는 발생하지 않는다. 런타임 시간은 줄고, 메모리 사용은 증가한다는 특징이 있다. record = [0 for _ in range(50)]record[0] = 1record[1] = 1def fibonacci(num): global record index = num - 1 if record[index] == 0: record[index] = fibonacci(num - 1) + fibonacci(num - 2) return record[index] 값이 리스트에 저장해되어 있기 때문에 중복 계산을 생략할 수 있다. TabulationMemoiation과 동일하게 함수 중복을 줄여주는 방식. 다른 점이라면 미리 피보나치를 필요한 만큼 계산해두고 꺼내쓰는 방식이다. record = [0 for _ in range(50)]record[0] = 1record[1] = 1def fibonacci_table(): global record for i in range(2, 50): record[i] = record[i-1] + record[i-2]fibonacci_table()","link":"/2023/01/05/202301/%EC%9E%AC%EA%B7%80(Recursion)%EC%99%80-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5(Divide-and-Conquer)/"},{"title":"파이썬 클래스 정렬","text":"클래스 객체를 정렬하기리스트 안의 내용물을 클래스 객체로 만들어서, 정렬하고자 할 때 쓰이는 방법입니다. class Data: def __init__(self, value): self.value = value def __lt__(self, other): #정렬의 기준을 정함 return self.value &lt; other.valueDataList = []DataList.append(Data(5))DataList.append(Data(3))DataList.append(Data(7))DataList.append(Data(1))DataList.sort() sort에서 key값 이용해서 정렬하기다른 방법으로 sort의 key값을 직접 정해줄 수 있습니다. class Data: def __init__(self, value): self.value = valueDataList = []DataList.append(Data(5))DataList.append(Data(3))DataList.append(Data(7))DataList.append(Data(1))DataList.sort(key=lambda x: x.value) # 클래스 안에서 정렬의 기준으로 삼을 변수 지정","link":"/2023/01/06/202301/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EB%A0%AC/"},{"title":"위상정렬 (Topology Sort)","text":"위상정렬 (Topology Sort) 예시코드from collections import dequeMAX = 8degrees = [0 for _ in range(MAX)]graphs = [[] for _ in range(MAX)]text = [ 0, '대학생 되기', '4학년 되기', '정보처리기사 합격하기', '자격 서류 제출하기','학과 사이트 가입하기', '졸업시험 신청하기', '졸업하기']result = ''def addLine(node1, node2): graphs[node1].append(node2) degrees[node2] += 1addLine(1, 2)addLine(2, 3)addLine(3, 4)addLine(1, 5)addLine(5, 6)addLine(4, 6)addLine(6, 7)print(degrees) # [0, 0, 1, 1, 1, 1, 2, 1]print(graphs) # [[], [2, 5], [3], [4], [6], [6], [7], []]def topologySort(): global result queue = deque() # 진입차수가 0인 노드 찾기 for n in range(1,MAX): if degrees[n] == 0: queue.append(n) for n in range(1,MAX): if not queue: print(&quot;사이클 발생&quot;) return node = queue.popleft() result += f'{text[node]}' if n != MAX-1: result += f' → ' for x in range(len(graphs[node])): next = graphs[node][x] degrees[next] -= 1 if degrees[next] == 0: queue.append(next) print(result)topologySort() 결과대학생 되기 → 4학년 되기 → 학과 사이트 가입하기 → 정보처리기사 합격하기 → 자격 서류 제출하기 → 졸업시험 신청하기 → 졸업하기","link":"/2023/01/05/202301/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC-(Topology-Sort)/"}],"tags":[{"name":"프로그래밍","slug":"프로그래밍","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"코딩테스트","slug":"코딩테스트","link":"/tags/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"리눅스","slug":"리눅스","link":"/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"pages":[]}